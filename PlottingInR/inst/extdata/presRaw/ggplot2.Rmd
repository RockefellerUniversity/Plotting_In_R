---
title: "Introduction to ggplot2"
author: "Rockefeller University, Bioinformatics Resource Centre"
date: "http://rockefelleruniversity.github.io/Plotting_In_R/"
output: 
  xaringan::moon_reader:
    css: ["default", "metropolisCustom.css", "metropolis-fontsCustom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
  html_document:
    toc: true # table of content true
    toc_float: yes
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
params:
  isSlides: "no"
---
```{r setup, include=FALSE}
suppressPackageStartupMessages(require(knitr))
knitr::opts_chunk$set(echo = TRUE, tidy = T)
if(params$isSlides == "yes"){AsSlides=T}else{AsSlides=F}
```


```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides != "yes"){
  cat("# Plotting in R with ggplot2
  
---
"    
  )
  
}

```

## Graphics in R

The R language has extensive graphical capabilities.

Graphics in R may be created by many different methods including base graphics and more advanced plotting packages such as lattice.

![](imgs/plotsinR.jpg)

---
## ggplot2

The ggplot2 package was created by Hadley Wickham to provide an intuitive plotting system to rapidly generate publication quality graphics.

ggplot2 builds on the concept of the "Grammar of Graphics" (Wilkinson 2005, Bertin 1983) which describes a consistent syntax for the construction of a wide range of complex graphics by a concise description of their components.

ggplot2 is a core part of the Tidyverse, a group of packages designed to make data science easy and functional in R. To get an introduction to the core concepts of Tidyverse check out our training materials [here](https://rockefelleruniversity.github.io/RU_tidyverse_core/).

---
## Why use ggplot2

The structured syntax and high level of abstraction used by ggplot2 should allow for the user to concentrate on the visualizations instead of creating the underlying code.

On top of this central philosophy ggplot2 has:

- Increased flexible over many plotting systems.
- An advanced theme system for professional/publication level graphics.
- Large developer base -- Many libraries extending its flexibility.
- Large user base -- Great documentation and active mailing list.

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Grammar of Graphics

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Grammar of Graphics
  
---
"    
  )
  
}

```

## How ggplot2 builds a plot

<!-- ![](imgs/Slide2.jpg) -->
<div align="center">
<img src="imgs/Slide2.jpg" alt="igv" height="500" width="550">
</div>


---
## Example scatter plot
Overview of example code for the ggplot2 scatter plot.

```{r complex_ggplot2,eval=F}

ggplot(data = <default data set>, 
       aes(x = <default x axis variable>,
           y = <default y axis variable>,
           ... <other default aesthetic mappings>),
       ... <other plot defaults>) +

       geom_scatter(aes(size = <size variable for this geom>, 
                      ... <other aesthetic mappings>),
                  data = <data for this point geom>,
                  stat = <statistic string or function>,
                  position = <position string or function>,
                  color = <"fixed color specification">,
                  <other arguments, possibly passed to the _stat_ function) +

  scale_<aesthetic>_<type>(name = <"scale label">,
                     breaks = <where to put tick marks>,
                     labels = <labels for tick marks>,
                     ... <other options for the scale>) +
  
  ggtitle("Graphics/Plot")+
  xlab("Weight")+
  ylab("Height")+

  theme(plot.title = element_text(color = "gray"),
        ... <other theme elements>)
    
```

---
## What users are required to specify

<!-- ![](imgs/Slide3.jpg) -->
<div align="center">
<img src="imgs/Slide3.jpg" alt="igv" height="500" width="550">
</div>

---
## Actual example scatter plot

```{r present_cleanEralt_ggplot2, echo=FALSE}
library(ggplot2)

patients_clean <- read.delim("data/patient-data-cleaned.txt",
                             sep="\t")

```

```{r simple_ggplot2,eval=T,warning=FALSE,fig.height=4.5,fig.width=9}
ggplot(data=patients_clean,
       aes(y=Weight,x=Height,color=Sex,
           size=BMI,shape=Pet)) + 
  geom_point()

```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Getting Started With ggplot2

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Getting Started With ggplot2
  
---
"    
  )
  
}

```

## Getting started with ggplot2

```{r load_packages_ggplot2, echo=FALSE, eval=TRUE,warning=F,message=F}
suppressPackageStartupMessages(library(tidyr))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(stringr))
suppressPackageStartupMessages(library(lubridate))
suppressPackageStartupMessages(library(ggpubr))

```

First we need a dataset. Here we read some data from the *data* directory using the **read.delim()** function.

We can use the **class()** function to get the data.type of our table and **dim()**  function to get the numbers of row and column.

```{r present_clean_ggplot2}
library(ggplot2)
patients_clean <- read.delim("data/patient-data-cleaned.txt",sep="\t")

class(patients_clean)
dim(patients_clean)
```

---

# Review the data

We can just review the first two rows to get an idea of the content of data

```{r present_clean2_ggplot2}
patients_clean[1:2,]
```

---
# Review the data.frame

By default, R's read.delim function has read in the data as a data.frame. 

Data.frames are essential for ggplot2 as we can have mixes of numerical, character and catergorical data in one table.

```{r present_clean3_ggplot2}
patients_clean$Smokes[1:5]
patients_clean$Height[1:5]
```
---
# Review the data.frame with summary

We can get an overview of the data in all columns of data.frame using the **summary()** function

```{r present_clean4_ggplot2}
summary(patients_clean)
```

---
## Our first ggplot2 graph

As seen above, in order to produce a ggplot2 graph we need a minimum of:

- Data to be used in graph
- Mappings of data to the graph (*aesthetic* mapping)
- What type of graph we want to use (The *geom* to use).

---
## Our first ggplot2 graph
In the code below we define the data as our cleaned patients data frame.

```{r ggplot_only_ggplot2,echo=!AsSlides,eval=!AsSlides}
pcPlot <- ggplot(data=patients_clean)
class(pcPlot)
pcPlot$data[1:4,]
```

```{r ggplot_onlyFS1_ggplot2,echo=AsSlides,eval=AsSlides}
pcPlot <- ggplot(data=patients_clean)
class(pcPlot)
```

Now we can see that we have gg/ggplot object (pcPlot).

---
## Our first ggplot2 graph

Within this gg/ggplot object the data has been defined.
```{r ggplot_onlyFS2_ggplot2,echo=AsSlides,eval=AsSlides}
pcPlot$data[1:4,]
```

---
## Our first ggplot2 graph
Important information on how to map the data to the visual properties (aesthetics) of the plot as well as what type of plot to use (geom) have however yet to specified. 

```{r missing_rest_ggplot2}
pcPlot$mapping
pcPlot$theme
pcPlot$layers
```

---
## Our first ggplot2 graph

The information to map the data to the plot can be added now using the aes() function.
```{r ggplot_aes_ggplot2}
pcPlot <- ggplot(data=patients_clean)

pcPlot <- pcPlot+aes(x=Height,y=Weight)

pcPlot$mapping
pcPlot$theme
pcPlot$layers
```

But we are still missing the final component of our plot, the type of plot to use (geom).

---
## Our first ggplot2 graph
Below the geom_point function is used to specify a point plot, a scatter plot of Height values on the x-axis versus Weight values on the y values.

```{r ggplot_aes_geom_ggplot2,fig.height=4,fig.width=7,eval=!AsSlides,echo=!AsSlides}
pcPlot <- ggplot(data=patients_clean)

pcPlot <- pcPlot+aes(x=Height,y=Weight)
pcPlot <- pcPlot+geom_point()
pcPlot
pcPlot$mapping
pcPlot$theme
pcPlot$layers

```

```{r ggplot_aes_geomFS1_ggplot2,fig.height=5,fig.width=8,eval=AsSlides,echo=AsSlides}
pcPlot <- ggplot(data=patients_clean)

pcPlot <- pcPlot+aes(x=Height,y=Weight)
pcPlot <- pcPlot+geom_point()

```

---
## Our first ggplot2 graph
```{r ggplot_aes_geomFS2_ggplot2,fig.height=5,fig.width=8,eval=AsSlides,echo=AsSlides}

pcPlot$mapping
pcPlot$theme
pcPlot$layers

```


---
## Our first ggplot2 graph
Now we have all the components of our plot, we need we can display the results.

```{r ggplot_aes_geom_display_ggplot2,fig.height=6,fig.width=8}
pcPlot

```


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Geoms

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Geoms
  
---
"    
  )
  
}

```

## Our first ggplot2 graph
More typically, the data and aesthetics are defined within ggplot function and geoms applied afterwards. This makes it easier to switch between plot types to find the best way to visualize your data.

```{r ggplot_simple_geom_point_ggplot2, fig.height=5, fig.width=8}
pcPlot <- ggplot(data=patients_clean,
                 mapping=aes(x=Height,y=Weight))
pcPlot+geom_point()
```

## Plot types

There are many geoms available in ggplot2:

* geom_point() - Scatter plots
* geom_line() - Line plots
* geom_smooth() - Fitted line plots
* geom_bar() - Bar plots
* geom_boxplot() - Boxplots
* geom_jitter() - Jitter to plots
* geom_histogram() - Histogram plots
* geom_density() - Density plots
* geom_text() - Text to plots
* geom_errorbar() - Errorbars to plots
* geom_violin() - Violin plots

---
## Line plots

```{r, line_simple_ggplot2, fig.height=5, fig.width=8}
pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Height,y=Weight))

pcPlot_line <- pcPlot+geom_line() 

pcPlot_line

```

---
## Smoothed line plots

```{r, smooth_simple_ggplot2, fig.height=4.5, fig.width=8}
pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Height,y=Weight))

pcPlot_smooth <- pcPlot+geom_smooth() 

pcPlot_smooth

```

---
## Bar plots

```{r, bar_simple_ggplot2, fig.height=5, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Sex))

pcPlot_bar <- pcPlot+geom_bar() 

pcPlot_bar


```

---
## Histograms

```{r, histogram_simple_ggplot2, fig.height=4, fig.width=8,warning=FALSE}
pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Height))

pcPlot_hist <- pcPlot+geom_histogram() 

pcPlot_hist

```

---
## Density plots

```{r, density_simple_ggplot2, fig.height=4.5, fig.width=8}
pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Height))

pcPlot_density <- pcPlot+geom_density() 

pcPlot_density

```

---
## Box plots

```{r, boxplot_simple_ggplot2, fig.height=5, fig.width=8}

pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Sex,y=Height))

pcPlot_boxplot <- pcPlot+geom_boxplot() 

pcPlot_boxplot
```

---
## Violin plots

```{r, violin_simple_ggplot2, fig.height=4.5, fig.width=8}

pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Sex,y=Height))

pcPlot_violin <- pcPlot+geom_violin() 

pcPlot_violin
```

---
## Multiple Geoms

We can also provide multiple geoms. Often we may want to do this to add complexity to our plot. In this case we often may like to see the data points driving our violin plot. So we also add a jitter on top. 

```{r, multiplegeom_ggplot2}
ggplot(data=patients_clean,
                 mapping=aes(x=Sex, y=Height))+ 
  geom_violin() +
  geom_jitter()
```




---
## There are a world of geoms 
An overview of geoms and their arguments can be found in the ggplot2 documentation or within the ggplot2 quick reference guides.

- [ggplot2 documentation](https://ggplot2.tidyverse.org/)

- [ggplot2 guide](http://sape.inf.usi.ch/quick-reference/ggplot2/geom)


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Aesthetics

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Aesthetics
  
---
"    
  )
  
}

```

## Aesthetics

In order to change the property on an aesthetic of a plot into a *constant* value (e.g. set color of all points to red) we can supply the color argument to the geom_point() function.

```{r, scatter_colored_ggplot2, fig.height=4, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
                 mapping=aes(x=Height,y=Weight))
pcPlot+geom_point(color="red")
```

---
## Plot properties
.pull-left[

As we discussed earlier however, ggplot2 makes use of aesthetic mappings to assign variables in the data to the properties/aesthetics of the plot. This allows the properties of the plot to reflect variables in the data *dynamically*.

In these examples we supply additional information to the aes() function to define what information to display and how it is represented in the plot.
  ]
.pull-right[

First we can recreate the plot we saw earlier.

```{r, scatter_simple_ggplot2, fig.height=4, fig.width=4,tidy=FALSE}
pcPlot <- ggplot(data=patients_clean,
                 mapping=aes(x=Height,
                             y=Weight))
pcPlot+geom_point()
```
  ]

---
## Color
Now we can adjust the aes mapping by supplying an argument to the color parameter in the aes function. (Note that ggplot2 accepts "color" or "color" as parameter name)


This simple adjustment allows for identification of the separation between male and female measurements for height and weight.

```{r, scatter_aes_sexcolor_ggplot2, fig.height=4, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
                 mapping=aes(x=Height,y=Weight,color=Sex))
pcPlot + geom_point()
```

---
## Point shape
Similarly the shape of points may be adjusted.

```{r, scatter_aes_sexShape_ggplot2, fig.height=4.5, fig.width=9,eval=F,echo=T}
pcPlot <- ggplot(data=patients_clean,
                 mapping=aes(x=Height,y=Weight,shape=Sex))
pcPlot+geom_point()
```

```{r, scatter_aes_sexShapeB_ggplot2, fig.height=4.5, fig.width=9,eval=T,echo=FALSE}
pcPlot <- ggplot(data=patients_clean,
                 mapping=aes(x=Height,y=Weight,shape=Sex))
pcPlot+geom_point(size=2)
```

---
## Aesthetics in geom
The aesthetic mappings may be set directly in the geom_points() function as previously when specifying red. This can allow the same ggplot object to be used by different aesthetic mappings and varying geoms.

```{r, aes_in_geom_ggplot2,eval=!AsSlides,echo=!AsSlides}
pcPlot <- ggplot(data=patients_clean)
pcPlot+geom_point(aes(x=Height,y=Weight,color=Sex))
pcPlot+geom_point(aes(x=Height,y=Weight,color=Smokes))
pcPlot+geom_point(aes(x=Height,y=Weight,color=Smokes,shape=Sex))
pcPlot+geom_violin(aes(x=Sex,y=Height,fill=Smokes))
```

```{r, aes_in_geomFS1_ggplot2,eval=AsSlides,echo=AsSlides}
pcPlot <- ggplot(data=patients_clean)
```

---
## Aesthetics in geom
```{r, aes_in_geomFS2_ggplot2,eval=AsSlides,echo=AsSlides}
pcPlot+geom_point(aes(x=Height,y=Weight,color=Sex))
```

---
## Aesthetics in geom
```{r, aes_in_geomFS3_ggplot2,eval=AsSlides,echo=AsSlides}
pcPlot+geom_point(aes(x=Height,y=Weight,color=Smokes))
```

---
## Aesthetics in geom
```{r, aes_in_geomFS4_ggplot2,eval=AsSlides,echo=AsSlides}
pcPlot+geom_point(aes(x=Height,y=Weight,color=Smokes,shape=Sex))
```

---
## Aesthetics in geom
```{r, aes_in_geomFS5_ggplot2,eval=AsSlides,echo=AsSlides}
pcPlot+geom_violin(aes(x=Sex,y=Height,fill=Smokes))
```

---
## Geom paramters

Many Geoms will have some specific aesthetics for that plot type. In this case we may want to adjust the width of our jitter to make it a bit more narrow and focused.

```{r, multiplegeom_ggplot2_2, fig.height=4, fig.width=7}
ggplot(data=patients_clean,
                 mapping=aes(x=Sex, y=Height, fill=Sex))+ 
  geom_violin() +
  geom_jitter(width=0.2)
```


---
## Aesthetics in geom

Again, for a comprehensive list of parameters and aesthetic mappings used in geom_*type* functions see the ggplot2 documentation for individual geoms by using ?geom_*type*

```{r, helpforArguments_ggplot2}
?geom_point
```

or visit the ggplot2 documentations pages and quick reference:

- [ggplot2 documentation](http://docs.ggplot2.org/current/)

- [Quick Reference](http://sape.inf.usi.ch/quick-reference/ggplot2/geom)


---
Exercise on the principles of ggplot can be found [here](../../exercises/exercises/ggplot2_1_exercise.html)

---

Answers for the principles of ggplot can be found [here](../../exercises/answers/ggplot2_1_answers.html)

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Facets

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Facets
  
---
"    
  )
  
}

```

## Facets

One very useful feature of ggplot is faceting. 
This allows you to produce several plots that subset by variables in your data.

To facet our data into multiple plots we can use the *facet_wrap* or *facet_grid* function specifying the variable we split by.

The *facet_grid* function is well suited to splitting the data by two factors.

---
## Split by 2 factors

Here we can plot the data with the Smokes variable as rows and Sex variable as columns.

<div align="center">
facet_grid(Rows~Columns)
</div>

```{r, facet_grid_SmokesBySex_ggplot2, fig.height=4, fig.width=9}
pcPlot <- ggplot(data=patients_clean,aes(x=Height,y=Weight,
                                         color=Sex))+geom_point()
pcPlot + facet_grid(Smokes~Sex)
```

---
## Split by 1 factor

To split by one factor we use the the facet_grid() function again, but omit the variable before the "~". This will facet along columns in plot.

<div align="center">
facet_grid(~Columns)
</div> 
```{r, facet_grid_BySex_ggplot2, fig.height=4, fig.width=9}
pcPlot <- ggplot(data=patients_clean,aes(x=Height,y=Weight,
                                         color=Sex))+geom_point()
pcPlot + facet_grid(~Sex)
```

---
## Split by 1 factor

Similarly, to split along rows in plot, the variable is placed before the "~.".

<div align="center">
facet_grid(Rows~.)
</div> 

```{r, facet_grid_SexBy_ggplot2, fig.height=4, fig.width=9}
pcPlot <- ggplot(data=patients_clean,aes(x=Height,y=Weight,
                                         color=Sex))+geom_point()
pcPlot + facet_grid(Sex~.)
```

---
## facet_wrap()

The *facet_wrap()* function offers a less grid-based structure but is well suited to faceting data by one variable.

For *facet_wrap()* we follow as similar syntax to *facet_grid()*.

```{r, facet_Wrap_BySmokes_ggplot2, fig.height=4, fig.width=9, eval=F}
pcPlot <- ggplot(data=patients_clean,aes(x=Height,y=Weight,
                                         color=Sex))+geom_point()
pcPlot + facet_wrap(~Smokes)
```

```{r, facet_Wrap_BySmokes_ggplot2_2, fig.height=4, fig.width=9, eval=T, echo=F}
pcPlot <- ggplot(data=patients_clean,aes(x=Height,y=Weight,
                                         color=Sex))+geom_point()
pcPlot + facet_wrap(~Smokes)+ theme(strip.text.x = element_text(size = 8))
```



---
## Multiple variables
For more complex faceting both *facet_grid* and *facet_wrap* can accept combinations of variables. Here we use *facet_wrap*.

```{r, facet_wrap_smokesBySexandPet_ggplot2, fig.height=4.5, fig.width=9}
pcPlot <- ggplot(data=patients_clean,aes(x=Height,y=Weight,
                                         color=Sex))+geom_point()
pcPlot + facet_wrap(~Pet+Smokes+Sex)
```

---
## Multiple variables
Or in a nice grid format using facet_grid() and the Smokes variable against a combination of Gender and Pet.

```{r, facet_grid_smokesBySexandPet_ggplot2_2, fig.height=5, fig.width=12}
pcPlot + facet_grid(Smokes~Sex+Pet)
```


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Plotting Order

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Plotting Order
  
---
"    
  )
  
}

```

## Plotting order in ggplot

We will shortly discuss how to change various aspects of the plot layout and appearance. However, a common-asked question is how to change the order in which R plots a categorical variable. Consider the boxplot to compare weights of males and females:

```{r plotOrderBoxplot_ggplot2, fig.height=4, fig.width=9}
ggplot(patients_clean, aes(x=Sex, y=Weight)) + geom_boxplot()
```

---
## Plotting order and factors

Here, R decides the order to arrange the boxes according to the `levels` of the categorical variable. If there are no levels or the levels are not ordered it defaults to the alphabetical order. i.e. Female before Male.

```{r plotOrderCatBoxplot_ggplot2}
levels(patients_clean$Sex)
```

---
## Plotting order and factors
Depending on the message we want the plot to convey, we might want control over the order of boxes. The `factor` functions allows us to explicitly change the order of the levels.

```{r plotOrderControlBoxplot_ggplot2, fig.height=4, fig.width=9}
patients_clean$Sex <- factor(patients_clean$Sex, 
                             levels=c("Male","Female"))
ggplot(patients_clean,aes(x=Sex, y=Weight)) + geom_boxplot()
```


```{r plotOrderControlBoxplotEval_ggplot2,echo=FALSE,eval=FALSE}
patients_clean %>% 
  mutate(Sex = factor(Sex,levels=c("Male","Female"))) %>% 
  ggplot(aes(x=Sex, y=Weight)) + geom_boxplot()
```



---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Scales

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Scales
  
---
"    
  )
  
}

```

## Scales

Scales and their legends have so far been handled using ggplot2 defaults.
ggplot2 offers functionality to have finer control over scales and legends using the *scale* methods.

Scale methods are divided into functions by combinations of 

* the aesthetics they control.

* the type of data mapped to scale.

 
  scale_aesthetic_type
  
  Try typing in scale_ then *tab* to autocomplete. This will provide some examples of the scale functions available in ggplot2.

---
## Arguments
Although different *scale* functions accept some variety in their arguments, common arguments to scale functions include: 

- name - The axis or legend title

- limits - Minimum and maximum of the scale

- breaks - Label/tick positions along an axis

- labels - Label names at each break

---
## Controlling the X and Y scale.

Both continuous and discrete X/Y scales can be controlled in ggplot2 using:

scale\_**(x/y)**\_**(continuous/discrete)**

---
## Continuous axes scales
In this example we control the continuous scale on the x-axis by providing a name, X-axis limits, the positions of breaks (ticks/labels) and the  labels to place at breaks.

```{r scaleCont_ggplot2, facet_grid_smokesBySex_scalex, fig.height=4.5, fig.width=9}

pcPlot + geom_point() + facet_grid(Smokes~Sex)+
  scale_x_continuous(name="height ('cm')",
                     limits = c(100,200),
                     breaks=c(125,150,175),
                     labels=c("small","justright","tall"))

```

---
## Discrete axes scales
Similarly control over discrete scales is shown below.

```{r scaleDiscrete_ggplot2, facet_grid_smokesBySex_scaleDisceteX, fig.height=5, fig.width=9}
pcPlot <- ggplot(data=patients_clean,aes(x=Sex,y=Height))
pcPlot +
  geom_violin(aes(x=Sex,y=Height)) +
  scale_x_discrete(labels=c("Women", "Men"))

```

---
## Combining axes scales
Multiple X/Y scales can be combined to give full control of axis marks.

```{r scaleFullControl_ggplot2, facet_grid_smokesBySex_scaleDisceteXContinuousY, fig.height=5, fig.width=9}
pcPlot <- ggplot(data=patients_clean,aes(x=Sex,y=Height,fill=Smokes))
pcPlot +
  geom_violin(aes(x=Sex,y=Height)) +
  scale_x_discrete(labels=c("Women", "Men"))+
  scale_y_continuous(breaks=c(160,180),labels=c("Short", "Tall"))
```

---
## Controlling other scales
When using fill, color, linetype, shape, size or alpha aesthetic mappings the scales are automatically selected for you and the appropriate legends created.


```{r scaleOthers_ggplot2, facet_grid_height_weight, fig.height=3, fig.width=8}
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,color=Sex))
pcPlot + geom_point(size=4)
                  
```

In the above example the discrete colors for the Sex variable was selected by default.

---
## Manual discrete color scale

Manual control of discrete variables can be performed using scale\_*aes_Of_Interest*\_**manual** with the *values* parameter.
Additionally in this example an updated name for the legend is provided.

```{r, facet_grid_height_weight_manualScale_ggplot2, fig.height=4, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,color=Sex))
pcPlot + geom_point(size=4) + 
  scale_color_manual(values = c("Green","Purple"),
                     name="Gender")
                  
```

---
## Named Colors and hex codes

Most colors can simply be defined by writing them in as a character vector i.e. "green". There are a wide variety of named colors available in R. From "darkgoldenrod" to "bisque". And 100 different shades of gray. You can find an extensive list of R colors [here](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf).

You can also use hex codes: a hexadecimal format for identifying colors. This gives greater variety of options as they use the full color spectrum. Each pair of characters corresponds to the Red, Green and Blue content for the color i.e. #ffe4c4 (also known as Bisque) is composed of 100% red, 89.4% green and 76.9% blue. Resources like this [color picker](https://htmlcolorcodes.com/color-picker/) can be used to help you find specific shades, and even create complementary palettes. 



---
## Packages for color scales

Here we have specified the colors to be used (hence the scale_color_**manual**) but when the number of levels to a variable are high this may be impractical and often we would like ggplot2 to choose colors from a scale of our choice.

There are a number of collections of in-built and installable package palettes in ggplot2, namely [colorbrewer](http://colorbrewer2.org/), [paleteer](https://r-graph-gallery.com/color-palette-finder) and [viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html). Palettes are prebuilt collections of colors. They can consist of a various numbers of colors and can have different properties i.e. continuous/discrete or divergent

---
## scale_color_brewer

Colorbrewer comes with ggplot

```{r, facet_grid_height_weight_brewerScale_ggplot2, fig.height=5, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,color=Pet))
pcPlot + geom_point(size=4) + 
  scale_color_brewer(palette = "Set2")
                  
```

---
## scale_color_paletteer_d

Paletteer is a collection of user-defined palettes that have been collated. They have wildly different rationales including famous artworks, Wes Anderson movies and Birds.

```{r, facet_grid_height_weight_brewerScale_ggplot2_2, fig.height=5, fig.width=9}
library(paletteer)
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,color=Pet))
pcPlot + geom_point(size=4) + 
  scale_color_paletteer_d(palette = "wesanderson::Zissou1")
                  
```

---
## scale_color_viridis_d

Viridis is a collection scientifically designed color palette to help with color blindness and to accurately show the dynamic range in data sets. 

```{r, facet_grid_height_weight_brewerScale_ggplot2_2, fig.height=5, fig.width=9}

pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,color=Pet))
pcPlot + geom_point(size=4) + 
  scale_color_viridis_d()
                  
```

---
## Color blindness + Uniform Perception

Using custom colors is great and can really help a make a piece of work cohesive and stand out. But you have to be careful. 

~4% of people are color blind. In white males this number raises to ~10%. Considering the demographics in science, there will likely be someone with color blindness in your meeting.

Furthermore, when we pick gradients the ability to see patterns in the data varies depending on the color scales used, even in sighted people.

---
## Color blindness + Uniform Perception

![palettes](imgs/uniform_colors.png)

(Crameri et al, 2020)



---
## Palettes

For more details on palette sizes and styles visit the colorbrewer website and ggplot2 reference page.

- [Colorbrewer](http://colorbrewer2.org/)
- [Paleteer](https://r-graph-gallery.com/color-palette-finder)
- [Viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html)
- [ggplot2 color scales](https://ggplot2.tidyverse.org/reference/scale_brewer.html)

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Continuous Scales

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Continuous Scales
  
---
"    
  )
  
}

```

## Continuous scales

So far we have looked a qualitative scales but ggplot2 offers much functionality for continuous scales such as for size, alpha (transparency), color and fill.

- scale_alpha_continuous() - For transparency

- scale_size_continuous() - For control of size.

---
## Alpha

Both these functions accept the range of alpha/size to be used in plotting.

Below the range of alpha to be used in plot is limited to between 0.5 and 1.

```{r, facet_grid_height_weight_BMIalpha_ggplot2, fig.height=4.5, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,alpha=BMI))
pcPlot + geom_point(size=4) + 
  scale_alpha_continuous(range = c(0.5,1))

                 
```

---
## Size
Below the range of sizes to be used in plot is limited to between 3 and 6.
```{r, facet_grid_height_weight_BMIsize_ggplot2, fig.height=5, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,size=BMI))
pcPlot + geom_point(alpha=0.8) + 
  scale_size_continuous(range = c(3,6))
                  
```
---
## Limits
The limits of the scale can also be controlled but it is important to note data outside of scale is removed from plot.

```{r, facet_grid_height_weight_BMIsizeLimits_ggplot2, fig.height=4, fig.width=9,warning=FALSE}
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,size=BMI))
pcPlot + geom_point() + scale_size_continuous(range = c(3,6),
                                              limits = c(25,40))
                  
```

---
## Labels
What points of scale to be labeled and labels text can also be controlled.

```{r, facet_grid_height_weight_BMIsizewithBreaks_ggplot2, fig.height=4, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,size=BMI))
pcPlot + geom_point() + 
  scale_size_continuous(range = c(3,6), 
                        breaks=c(25,30), 
                        labels=c("Good","Good but not 25"))
```

---
## Color
Control of color/fill scales can be best achieved through the **gradient** subfunctions of scale.


- scale_(color/fill)_*gradient* - 2 color gradient (eg. low to high BMI)

- scale\_(color/fill)\_*gradient2* - Diverging color scale with a midpoint color (e.g. Down, No Change, Up)

Both functions take a common set of arguments:-

- low - color for low end of gradient scale
- high - color for high end of gradient scale.
- na.value - color for any NA values.

---
## Color
An example using scale\_color\_gradient below sets the low and high end colors to White and Red respectively


```{r, facet_grid_height_weight_BMIgradient_ggplot2, fig.height=4, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,color=BMI))
pcPlot + geom_point(size=4,alpha=0.8) + 
  scale_color_gradient(low = "White",high="Red")
                  
```

---
## Color
Similarly we can use the scale_color_gradient2 function which allows for the specification of a midpoint value and its associated color.

```{r, facet_grid_height_weight_BMIgradient2_ggplot2, fig.height=4, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,color=BMI))
pcPlot + geom_point(size=4,alpha=0.8) + 
  scale_color_gradient2(low = "Blue",mid="Black", high="Red",
                         midpoint = median(patients_clean$BMI))
```

---
## Labels
As with previous continuous scales, limits and custom labels in scale legend can be added.

```{r, facet_grid_height_weight_BMIgradient2plus_ggplot2, fig.height=3.5, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,color=BMI))
pcPlot + geom_point(size=4,alpha=0.8) + 
  scale_color_gradient2(low = "Blue",
                         mid="Black",
                         high="Red",
                         midpoint = median(patients_clean$BMI),
                         breaks=c(25,30),labels=c("Low","High"),
                         name="Body Mass Index")
```

---
## Scales are very customizable
Multiple scales may be combined to create high customizable plots and scales

```{r, facet_grid_smokesBySex_scaleDisceteXContinuouswY_ggplot2, fig.height=4, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,color=BMI,shape=Sex))
pcPlot + geom_point(size=4,alpha=0.8)+ 
  scale_shape_discrete(name="Gender") +
  scale_color_gradient2(low = "Blue",mid="Black",high="Red",
                         midpoint = median(patients_clean$BMI),
                         breaks=c(25,30),labels=c("Low","High"),
                         name="Body Mass Index")
```

---

## Conditional scales and colors

We can also use an ifelse conditional statement to apply discrete color cutoffs for groups of data points that aren't represented by categorical variables in the data set. 

```{r, conditional_colors_scales, fig.height=4, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
                 aes(x=Height,y=Weight,shape=Sex, color=ifelse(BMI > 30, "High",
                                                                ifelse(BMI < 25, "Low", "Middle"))))
pcPlot + geom_point(size=4,alpha=0.8) + 
  scale_shape_discrete(name="Gender") +
  scale_color_manual(name = "BMI category", values=c("red", "blue", "grey"))
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Transformations

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Transformations
  
---
"    
  )
  
}

```

## Statistical transformations

In ggplot2, many of the statistical transformations are performed without any direct specification e.g. geom_histogram() will use stat_bin() function to generate bin counts to be used in plot.

An example of statistical methods in ggplot2 which are very useful include the stat_smooth() and stat_summary() functions.

---
## Fitting lines 

The stat_smooth() function can be used to fit a line to the data being displayed.

```{r, stat_smooth_ggplot2, fig.height=5, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height))
pcPlot+geom_point() + 
  stat_smooth()
```

---
## Loess and more
By default a "loess" smooth line is plotted by stat_smooth. Other methods available include lm, glm, gam, rlm.

```{r, stat_smoothlm_ggplot2, fig.height=4, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height))
pcPlot+geom_point() + 
  stat_smooth(method="lm")

```

---
## Fitting lines in groups
A useful feature of ggplot2 is that it uses previously defined grouping when performing smoothing.

If color by Sex is an aesthetic mapping then two smooth lines are drawn, one for each sex.

```{r, stat_smoothlmgroups_ggplot2, fig.height=4, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height,color=Sex))
pcPlot+geom_point() +
  stat_smooth(method="lm")
```

---
## Fitting lines in groups
This behavior can be overridden by specifying an aes within the stat_smooth() function and setting inherit.aes to FALSE.

```{r, stat_smoothlmgroupsOverridden_ggplot2, fig.height=4, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height,color=Sex))
pcPlot+geom_point()+
  stat_smooth(aes(x=Weight,y=Height),method="lm",
                                inherit.aes = F)
```

---

## Marginal plots with ggEtxtra
Plots for either the X or Y axis variables can easily be added to the margins of the plot to display the distributions of variables. By default this is a line. The groupcolor and groupFill arguments carry over the color aesthetic of the main plot.  

```{r, marginal_ggplot, fig.height=4, fig.width=9, message = F}
library(ggExtra)
pcPlot <- ggplot(data=patients_clean,
                 mapping=aes(x=Weight,y=Height,color=Sex)) + geom_point()
ggMarginal(pcPlot, groupcolor = TRUE, groupFill = TRUE)
```

---

## Marginal plots with ggEtxtra
We can easily turn this into a histogram and only display either X or Y axis.  

```{r, marginal_ggplot2, fig.height=4, fig.width=9, message = F}

pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height,color=Sex)) + geom_point()
ggMarginal(pcPlot, groupcolor = TRUE, groupFill = TRUE, type = "histogram", margins = "x")
```


---

## Summary statistics
Another useful method is stat_summary() which allows for a custom statistical function to be performed and then visualized.

The fun parameter specifies a function to apply to the y variables for every value of x. In this example we use it to plot the quantiles of the Female and Male Height data

```{r, stat_summary_ggplot2, fig.height=3.5, fig.width=9}
pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Sex,y=Height)) + geom_jitter()
pcPlot + 
  stat_summary(fun=quantile, geom="point",
                    color="purple", size=8)
```

---

## Displaying fitted line statistics
The ggpubr package contains functions to make publication quality graphics by displaying statistics. Here we add the equation and the R squared value for the line of best fit. 

The after_stat function is required to tell ggplot to map the aesthetics after a function has computed the relevant statistics. 
 

```{r, line_eqn, fig.height=3, fig.width=8}
library(ggpubr)
pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height)) +
  geom_point() + 
  stat_smooth(method="lm", formula = y ~ x)  
pcPlot +
  stat_regline_equation(label.y = 185, aes(label = after_stat(eq.label)), formula = y ~ x) +
  stat_regline_equation(label.y = 183, aes(label = after_stat(rr.label)), formula = y ~ x)

```

---

## Displaying fitted line statistics
By giving subsets of the data to the stat_regline_equation() function, we can display statistics for each group that we make a line of best fit. 

```{r, line_eqn_groups, fig.height=3, fig.width=8}
pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height,color=Sex)) +geom_point()+ stat_smooth(aes(x=Weight,y=Height), method="lm", formula = y ~ x) 
pcPlot +
  stat_regline_equation(data = patients_clean[patients_clean$Sex == "Male", ], 
                        label.y = 183, aes(label = after_stat(rr.label)), formula = y ~ x) + 
  stat_regline_equation(data = patients_clean[patients_clean$Sex == "Female", ], 
                        label.x = 80, label.y = 160, aes(label = after_stat(rr.label)), formula = y ~ x)  
  
```

---

## Displaying stats on the plot
The ggpubr package also has useful functions that allows the display p-values on plots when combined with the rstatix package. 

Here we use rstatix to create a data frame with relevant statistics for our desired comparison, and then we add x and y position information. [Check out](https://rpkgs.datanovia.com/rstatix/) the the many other functions rstatix has to add information to this table (adhusted p, otehr stats tests, etc.)

```{r, add_p1, message = F}
library(rstatix)
# https://rpkgs.datanovia.com/rstatix/

stat.test <- t_test(patients_clean, Height ~ Sex) 
stat.test <- add_xy_position(stat.test, x = "Sex", dodge = 0.8)

data.frame(stat.test)
```

---

## Displaying stats on the plot
This data frame can then be used in the stat_pvalue_manual() function from ggpubr to add the pvalue. 

```{r, add_p2, fig.height=4, fig.width=8}

pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Sex,y=Height)) + 
  geom_boxplot()

# don't inherit aesthetic to make this work 
pcPlot + stat_pvalue_manual(stat.test, label = "p", inherit.aes = F) + scale_y_continuous(expand = expansion(mult = 0.1))

```

---

## Displaying stats for grouped data

By grouping the dataframe, we can look for differences between smokers within sex. We also add an adjusted p-value. 
```{r, grouped_p1}

grouped_data <- group_by(patients_clean, Sex)
stat.test <- t_test(grouped_data, formula = Height ~ Smokes) 
stat.test <- adjust_pvalue(stat.test, method = "BH") 
stat.test <- add_xy_position(stat.test, x = "Sex", dodge = 0.8)

data.frame(stat.test)
```

---

## Displaying stats for grouped data

We can also modify the label of the p-values by putting the column used for the p-value inside curly brackets {} within a string. 
```{r, grouped_p2, fig.height=4, fig.width=8}

pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Sex ,y=Height, fill = Smokes)) + 
  geom_boxplot() 

# don't inherit aesthetic to make this work 
pcPlot + stat_pvalue_manual(stat.test, label = "p = {p.adj}", inherit.aes = F) + scale_y_continuous(expand = expansion(mult = 0.1))
```


---


Exercise on scales and themes in ggplot can be found [here](../../exercises/exercises/ggplot2_2_exercise.html)

---

Exercise on scales and themes in ggplot can be found [here](../../exercises/answers/ggplot2_2_answers.html)


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Themes

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Themes
  
---
"    
  )
  
}

```

## Themes

Themes specify the details of data independent elements of the plot. 
This includes titles, background color, text fonts etc.

The graphs created so far have all used the default themes, `theme_grey()`, 
but ggplot2 allows for the specification of theme used.

---
## Predefined themes

Predefined themes can be applied to a ggplot2 object using a family of functions theme_*style*()

.pull-left[

Here is a scatter with the default theme...
```{r, theme_default_ggplot2, fig.height=4, fig.width=4}
pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height))+geom_point()
pcPlot
```

  ]
.pull-right[

...and the same scatter plot with the minimal theme.

```{r, theme_minimal_ggplot2, fig.height=4, fig.width=4,tidy=FALSE}
pcPlot+theme_minimal()
```
  ]

---
## Predefined themes

Several predefined themes are available within ggplot2 including:

- theme_bw

- theme_classic

- theme_dark

- theme_gray

- theme_light

- theme_linedraw

- theme_minimal

You can review them [here](https://ggplot2.tidyverse.org/reference/ggtheme.html)

---
## Theme packages

There are many themes you can gain access to through installing additional packages. Packages such as [ggthemes](https://github.com/jrnold/ggthemes) also contain many useful collections of predefined theme_*style* functions.

Other alternatives include:
* [hrbrthemes](https://github.com/hrbrmstr/hrbrthemes) - focuses on controlling typography
* [ggthemr](https://github.com/Mikata-Project/ggthemr) - A large collection of themes - includes dark options
* [ggpomologica](https://www.garrickadenbuie.com/project/ggpomological/) - Hand drawn plots
* [tvthemes](https://ryo-n7.github.io/tvthemes/) - TV shows


---
## ggthemes

After we have loaded in the ggthemes packages we can then simply use the new themes available to using the theme_*style* convention of function.

.pull-left[

Here is a scatter with the default theme...
```{r, theme_default_ggplot2_2, fig.height=4, fig.width=4}
pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height)) + geom_point()
pcPlot
```

  ]
.pull-right[

...and the same scatter plot with the Wall Street Journal theme.

```{r, eval=F}
install.packages("ggthemes")

```

```{r, ggthemes, fig.height=4, fig.width=4,tidy=FALSE}
library(ggthemes)
pcPlot+theme_wsj()
```
  ]


---
## Custom themes

As well as making use of predefined theme styles, ggplot2 allows for control over the attributes and elements within a plot through a collection of related functions and attributes.

**theme()** is the global function used to set attributes for the collections of elements/components making up the current plot.

.pull-left[
Within the theme functions there are 4 general graphic elements which may be controlled...

- rect
- line
- text
- title
  ]

.pull-right[
...and 5 groups of related elements:

- axis
- legend
- strip
- panel (plot panel)
- plot (Global plot parameters)
]

---
## Custom themes

These elements may be specified by the use of their appropriate element functions including:

- element_line()
- element_text()
- element_rect()

and additionally element_blank() to set an element to "blank".

---
## Custom themes

A detailed description of controlling elements within a theme can be seen at the ggplot2 vignette and by typing *?theme* into the console.

- [ggplot2 themes](https://ggplot2.tidyverse.org/reference/index.html#section-themes)

---
## Customizing your theme
.pull-left[

To demonstrate customizing a theme, in the example below we alter one element of theme. Here we will change the text color for the plot.

- Note because we are changing a *text* element we use the *element_text()* function.

A detailed description of which elements are available and their associated element functions can be found by typing *?theme*.
  ]
.pull-right[

```{r, theme_custom_ggplot2, fig.height=7, fig.width=9,tidy=FALSE}

pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height))+
  geom_point()
pcPlot+
  theme(
    text = element_text(color="red")
      )
```
  ]

---
## Customizing your theme
If we wished to set the y-axis label to be at an angle we can adjust that as well.

```{r, theme_custom1_ggplot2, fig.height=4.5, fig.width=9}

pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height))+geom_point()
pcPlot + theme(text = element_text(color="red"),
        axis.title.y = element_text(angle=0))
```

---
## Customizing your theme

Finally we may wish to remove axis line, set the background of plot panels to be white and give the strips (title above facet) a cyan background color.

```{r, theme_custom2_ggplot2, fig.height=3, fig.width=9,eval=FALSE}

pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height))+
  geom_point()+
  facet_grid(Sex~Smokes)
pcPlot+
  theme(
    text = element_text(color="red"),
    axis.title.y = element_text(angle=0),
    axis.line = element_line(linetype = 0),
    panel.background=element_rect(fill="white"),
    strip.background=element_rect(fill="cyan")
    )
```

---
## Customizing your theme
Finally we may wish to remove axis line, set the background of plot panels to be white and give the strips (title above facet) a cyan background color.

```{r, theme_custom22_ggplot2, fig.height=3, fig.width=9,eval=TRUE,echo=FALSE}

pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height))+
  geom_point()+
  facet_grid(Sex~Smokes)
pcPlot+
  theme(
    text = element_text(color="red"),
    axis.title.y = element_text(angle=0),
    axis.line = element_line(linetype = 0),
    panel.background=element_rect(fill="white"),
    strip.background=element_rect(fill="cyan")
    )
```

---
## Useful example for legend

A useful example of using the theme can be seen in controlling the legend.
By default the legend is in right of plot.

```{r, legendD_ggplot2, fig.height=5, fig.width=9}
pcPlot <- ggplot(data=patients_clean,aes(x=Height,y=Weight,
                                         color=Sex))+geom_point()
pcPlot
```


---
## Useful example for legend

By modifying the theme we can control the legend positioning.

```{r, legendleft_ggplot2, fig.height=5, fig.width=9}
pcPlot <- ggplot(data=patients_clean,aes(x=Height,y=Weight,
                                         color=Sex))+geom_point()
pcPlot+theme(legend.position="left")
```

---
## Useful example for legend

We can control all aspects of a legend as we can for other theme elements.

```{r, legendText_ggplot2, fig.height=4, fig.width=8}
pcPlot <- ggplot(data=patients_clean,aes(x=Height,y=Weight,
                                         color=Sex))+geom_point()
pcPlot+theme(legend.text = element_text(color="darkred"),
             legend.title = element_text(size=20),
             legend.position = "bottom"
             )
```

---
## + and %+replace%

When altering themes we have been using the **+** operator to add themes as we would adding geoms,scales and stats.

When using the **+** operator 

- Themes elements specified in new scheme replace elements in old theme 

- Theme elements in the old theme which have not been specified in new theme are maintained.

This makes the **+** operator useful for building up from old themes.

---
## The **+** operator 
In the example below, we maintain all elements set by theme_bw() but overwrite the theme element attribute of the color of text.
```{r, theme_custom8_ggplot2, fig.height=5, fig.width=9}

pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height))+geom_point()+theme_bw()
pcPlot+
  theme(text = element_text(color="red"))
```

---
## **%+replace%**

In contrast **%+replace%** replaces all elements within a theme regardless of whether they have been previously specfied in old theme.

When using the **%+replace%** operator: 

- Theme elements specified in new scheme replace elements in old theme 

- Theme elements in the old theme which have not been specified in new theme are also replaced by blank theme elements.

```{r, theme_custom84_ggplot2,echo=!AsSlides,eval=!AsSlides}
  oldTheme <- theme_bw()
  
  newTheme_Plus <- theme_bw() +
  theme(text = element_text(color="red"))
  
  newTheme_Replace <- theme_bw() %+replace%
  theme(text = element_text(color="red"))
  
  oldTheme$text
  newTheme_Plus$text
  newTheme_Replace$text
```

```{r, theme_custom84FS1_ggplot2,echo=AsSlides,eval=AsSlides}
  oldTheme <- theme_bw()
  
  newTheme_Plus <- theme_bw() +
  theme(text = element_text(color="red"))
  
  newTheme_Replace <- theme_bw() %+replace%
  theme(text = element_text(color="red"))
```


---
## + and %+replace%
### Original theme 
```{r, theme_custom84FS2_ggplot2,echo=AsSlides,eval=AsSlides}
  oldTheme$text
```
---
## + and %+replace%
### Theme modified with **+**

```{r, theme_custom84FS3_ggplot2,echo=AsSlides,eval=AsSlides}
  newTheme_Plus$text
```
---
## + and %+replace%
### Theme modified with %+replace%

```{r, theme_custom84FS4_ggplot2,echo=AsSlides,eval=AsSlides}

  newTheme_Replace$text
```

This means that %+replace% is most useful when creating new themes.

---
## theme_get and theme_set

In the examples we have shown you we have been modifying the theme for a specific plot. But once you have a theme that you really like you may want it to apply to every plot you draw. 

The active theme is automatically applied to every plot you draw. Use theme_get to get the current theme, and theme_set to completely override it.

```{r, theme_custom84FS4wd_ggplot2,echo=AsSlides,eval=FALSE}
newTheme <- theme_bw()
theme_set(newTheme)
myTheme <- theme_get()
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Titles and Labels

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Titles and Labels
  
---
"    
  )
  
}

```

## Adding titles for plot and labels

So far no plot titles have been specified. Plot titles can be specified using the labs functions.

```{r, theme_labs_ggplot2,fig.height=5, fig.width=9,}

pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height))+geom_point()
pcPlot+labs(title="Weight vs Height",y="Height (cm)")
```

---
## Adding titles for plot and labels

You can also specify titles using the ggtitle and xlab/ylab functions.

```{r, theme_ggtitle_ggplot2,fig.height=5, fig.width=9,}

pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Height,y=Weight))+geom_point()
pcPlot+ggtitle("Weight vs Height")+ylab("Height (cm)")
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Saving Plots

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Saving Plots
  
---
"    
  )
  
}

```

## Saving plots

Plots produced by ggplot can be saved in the same way as [base plots](../singlepage/basePlotting.html#saving-your-plots)

The ggsave() function allows for additional arguments to be specified including the type, resolution and size of plot.

By default ggsave() will use the size of your current graphics window when saving plots so it may be important to specify width and height arguments desired. 

```{r, ggsaving_ggplot2, eval=FALSE,fig.height=4, fig.width=9,}

pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height))+geom_point()

ggsave(pcPlot,filename = "anExampleplot.png",width = 15,
       height = 15,units = "cm")
```


---
## Saving in pdf format

PDFs are maybe the most useful format to export into. PDFs are vector-based so each part of the plot is saved as scalable cooridnates as opposed to specific pixels. 

PDFs can then be opened in imaging software like illustrator or [inkscape](https://inkscape.org/) (this is a open source and free equivalent). When you open a PDF in these programs you can fully customize the plots to your aesthetic with a graphic user interface. Furthermore as they are vector-based, they can be easily assembled into publication quality figures without resolution issues and pixelation. 

```{r save_pdf_basePlotting,eval=FALSE}

pdf(file = "anExampleplot.pdf", paper = "A4")
plot(control)
dev.off()
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Interactive Plots

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Interactive Plots
  
---
"    
  )
  
}

```

## Interactive Plots

Most of the time when we are drawing plots the aim is to generate a saved file we can use for figures later. Sometimes though we may want to generate a interactive plot. This can be really useful to help parse our data, or if we want to generate dynamic reports to share our work.


```{R}
library(plotly)
```


---
## Interactive Plots

```{r, eval=FALSE,fig.height=4, fig.width=9,}

pcPlot <- ggplot(data=patients_clean,
        mapping=aes(x=Weight,y=Height))+geom_point()

ggplotly(pcPlot)
```

---
## Adding Annotation

To show off how we add additional annotation or work with more complex examples we have a ggplot object to load in. You can use the *load()* function with to read in this object: *data/pcPlot.RData*

```{r}
load("data/pcPlot.RData")

```


---
## Review the data

We can quickly check what is in the data, the aesthetics mapping, and any plot already in the ggplot object.

```{r}

head(pcPlot$data)

pcPlot$mapping

pcPlot$layers
```

```{r, echo=FALSE, eval=FALSE,fig.height=4, fig.width=9}

to_plot <- prcomp(assay(toPlot))$rotation-(prcomp(assay(toPlot))$rotation/matrix(rnorm(36), 6, 6)/100)

rownames(to_plot) <- c("A_1","A_2",
                       "B_1","B_2",
                       "C_1","C_2")
to_plot <- as.data.frame(to_plot)
to_plot$Sample <- rownames(to_plot)

to_plot$Time <- factor(c("0hr","0hr","2hr","2hr","12hr","12hr"), levels = c("0hr","2hr","12hr"))
to_plot$Rep <- factor(c("1","2","1","2","1","2"))
pca_res <- to_plot
pca_res[2,1:2] <- c(0.6090663,  0.5384380)
pca_res[3,1:2] <- c(0.4596307,  0.5424412)
pca_res[4,1:2] <- c(0.4190463,  0.4812430)
pca_res[5,1:2] <- c(0.3220796,  0.5434719)
pca_res[6,1:2] <- c(0.3130591,  0.4426442)
pcPlot <- ggplot(data=pca_res,
        mapping=aes(x=PC1,y=PC2, color= Time, shape=Rep))
save(pcPlot, file = "../data/pcPlot.RData")

```

---
## Lets make a plot

The aesthetic mappings are naturally inherited as labels. If we want to add custom labels we can specify it in our plot. 

```{r,fig.height=4, fig.width=9}

ggplotly(pcPlot)
```

---
## Extra Annotation

As the aesthetic mappings are naturally inherited as labels,we can just add an additional aesthetic. If we want to add custom labels we can specify it in our plot. 

```{r,fig.height=4, fig.width=9}

ggplotly(pcPlot + geom_point(aes(label = Sample)))
```

---
## Extra Annotation

If we want full control over the labeling we can instead use the ggplotly function to take care of this for us by specifying when/what/where labels are shown. 

```{r}
ggplotly(pcPlot + geom_point(aes(text = Sample )), source = "select", tooltip = c("Sample"))
```



---


Exercise on scales and themes in ggplot can be found [here](../../exercises/exercises/ggplot2_3_exercise.html)

---

Exercise on scales and themes in ggplot can be found [here](../../exercises/answers/ggplot2_3_answers.html)

---
## References

- [Layered grammar of graphics](http://vita.had.co.nz/papers/layered-grammar.pdf)

- [ggplot2 documentation](http://docs.ggplot2.org/current/)

- [ggplot2 wiki](https://github.com/hadley/ggplot2/wiki)

- [ggplot2 mailing list](http://groups.google.com/group/ggplot2)

- [Cheatsheet](http://sape.inf.usi.ch/quick-reference/ggplot2/geom)

- [Even more material](http://tutorials.iq.harvard.edu/R/Rgraphics/Rgraphics.html)

- [Fundamentals of Data Visualization](https://clauswilke.com/dataviz/) by Claus O. Wilke is a good resource on the theory of making data visualizations the right way, though there is no R code. 

---
## Contact

Any suggestions, comments, edits or questions (about content or the slides themselves) please reach out to our [GitHub](https://github.com/RockefellerUniversity/Plotting_In_R/issues) and raise an issue.
